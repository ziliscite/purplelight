package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/ziliscite/purplelight/internal/data"
)

type UserRepository struct {
	db     *pgxpool.Pool
	logger *dbLogger
}

func NewUserRepository(db *pgxpool.Pool, logger *dbLogger) UserRepository {
	return UserRepository{
		db:     db,
		logger: logger,
	}
}

// Insert a new record in the database for the user. Note that the id, created_at and
// version fields are all automatically generated by our database, so we use the
// RETURNING clause to read them into the User struct after the insert, in the same way
// that we did when creating a movie.
func (u UserRepository) Insert(user *data.User) error {
	opts := pgx.TxOptions{
		IsoLevel:   pgx.Serializable,
		AccessMode: pgx.ReadWrite,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	tx, err := u.db.BeginTx(ctx, opts)
	if err != nil {
		return u.logger.handleError(fmt.Errorf("%w: %s", ErrTransaction, err.Error()))
	}

	defer func() {
		if err != nil {
			// Rollback if an error occurs during the transaction
			if rbErr := tx.Rollback(ctx); rbErr != nil {
				u.logger.Error(ErrTransaction.Error(), "error", rbErr)
			}
		}
	}()

	query := `
        INSERT INTO users (name, email, password_hash, activated) 
        VALUES ($1, $2, $3, $4)
        RETURNING id, created_at, version
	`

	args := []any{user.Name, user.Email, user.Hash(), user.Activated}

	// If the table already contains a record with this email address, then when we try
	// to perform the insert there will be a violation of the UNIQUE "users_email_key"
	// constraint that we set up in the previous chapter. We check for this error
	// specifically, and return custom ErrDuplicateEmail error instead.
	err = tx.QueryRow(ctx, query, args...).Scan(&user.ID, &user.CreatedAt, &user.Version)
	if err != nil {
		switch {
		case errors.Is(err, sql.ErrNoRows):
			return ErrEditConflict
		default:
			return u.logger.handleError(err)
		}
	}

	// Commit transaction
	if err = tx.Commit(ctx); err != nil {
		return u.logger.handleError(fmt.Errorf("%w: %s", ErrTransaction, err.Error()))
	}

	return nil
}

// GetByEmail Retrieve the User details from the database based on the user's email address.
// Because we have a UNIQUE constraint on the email column, this SQL query will only
// return one record (or none at all, in which case we return a ErrRecordNotFound error).
func (u UserRepository) GetByEmail(email string) (*data.User, error) {
	opts := pgx.TxOptions{
		IsoLevel:   pgx.Serializable,
		AccessMode: pgx.ReadOnly,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	tx, err := u.db.BeginTx(ctx, opts)
	if err != nil {
		return nil, u.logger.handleError(fmt.Errorf("%w: %s", ErrTransaction, err.Error()))
	}

	defer func() {
		if err != nil {
			// Rollback if an error occurs during the transaction
			if rbErr := tx.Rollback(ctx); rbErr != nil {
				u.logger.Error(ErrTransaction.Error(), "error", rbErr)
			}
		}
	}()

	query := `
        SELECT id, created_at, name, email, password_hash, activated, version
        FROM users
        WHERE email = $1
	`

	var user data.User

	var hash []byte
	err = tx.QueryRow(ctx, query, email).Scan(
		&user.ID,
		&user.CreatedAt,
		&user.Name,
		&user.Email,
		&hash,
		&user.Activated,
		&user.Version,
	)

	user.Password.InsertHash(hash)

	if err != nil {
		switch {
		case errors.Is(err, sql.ErrNoRows):
			return nil, ErrRecordNotFound
		default:
			return nil, u.logger.handleError(err)
		}
	}

	// Commit transaction
	if err = tx.Commit(ctx); err != nil {
		return nil, u.logger.handleError(fmt.Errorf("%w: %s", ErrTransaction, err.Error()))
	}

	return &user, nil
}

// Update the details for a specific user. Notice that we check against the version
// field to help prevent any race conditions during the request cycle, just like we did
// when updating a movie. And we also check for a violation of the "users_email_key"
// constraint when performing the update, just like we did when inserting the user
// record originally.
func (u UserRepository) Update(user *data.User) error {
	opts := pgx.TxOptions{
		IsoLevel:   pgx.ReadCommitted,
		AccessMode: pgx.ReadWrite,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	tx, err := u.db.BeginTx(ctx, opts)
	if err != nil {
		return u.logger.handleError(fmt.Errorf("%w: %s", ErrTransaction, err.Error()))
	}

	defer func() {
		if err != nil {
			// Rollback if an error occurs during the transaction
			if rbErr := tx.Rollback(ctx); rbErr != nil {
				u.logger.Error(ErrTransaction.Error(), "error", rbErr)
			}
		}
	}()

	query := `
        UPDATE users 
        SET name = $1, email = $2, password_hash = $3, activated = $4, version = version + 1
        WHERE id = $5 AND version = $6
        RETURNING version
	`

	args := []any{
		user.Name,
		user.Email,
		user.Hash(),
		user.Activated,
		user.ID,
		user.Version,
	}

	err = tx.QueryRow(ctx, query, args...).Scan(&user.Version)
	if err != nil {
		switch {
		case errors.Is(err, sql.ErrNoRows):
			return ErrEditConflict
		default:
			return u.logger.handleError(err)
		}
	}

	// Commit transaction
	if err = tx.Commit(ctx); err != nil {
		return u.logger.handleError(fmt.Errorf("%w: %s", ErrTransaction, err.Error()))
	}

	return nil
}
